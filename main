#include "logger.h"
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <utility/imumaths.h>
#include <ESP32Encoder.h>


#define BAUDRATE_HOVER      115200       // [-] Baud rate for HoverSerial (used to communicate with the hoverboard)
#define ANGLE_LIMIT         100
#define SPEED_LIMIT         8000
#define BAUDRATE_PC         115200
#define BALANCE_AT          91.97//   92.93


int timer3 = 0;

class DynamicIncrease {
  public:
    unsigned long timer;
    DynamicIncrease() {
      timer = millis();
    };
    int current = 0;
    int target = 0;
    int step = 1;
    int interval = 20;
    void eval() {
      if ((millis() - timer) >= interval  and abs(target - current) >= step) {
        debug << "Current " << current;
        if (target > current)
          current += step;
        else
          current -= step;
      }
    }
};



bool breaked = false;

float K1 = 1138; // 903
float K2 = 55; // 68
float K3 = 620; // 348

float previous_error = 0;
float previous_theta = 0;
float pid = 0;
int init_time = 0;
int thetas[] = {0,0,0,0,0,0,0,0,0,0};

ESP32Encoder encoder1;
ESP32Encoder encoder2;

DynamicIncrease steer_speed = DynamicIncrease();
DynamicIncrease forward_speed = DynamicIncrease();

unsigned long last_time = 0;
unsigned long last_time2 = 0;
#define HoverSerial Serial2
int j = 0;
Adafruit_BNO055 bno = Adafruit_BNO055(); // instantiate IMU

void setup() {
  long firstTime = millis();
  //Serial init
  Serial.begin(BAUDRATE_PC); // Serial to PC
  ESP32Encoder::useInternalWeakPullResistors = DOWN;
  // Attache pins for use as encoder pins
  encoder1.attachHalfQuad(12, 13);
  // Attache pins for use as encoder pins
  encoder2.attachHalfQuad(27, 14);
  encoder1.clearCount();
  encoder2.clearCount();
  HoverSerial.begin(BAUDRATE_HOVER); //Serial to hoverboard
  imuInit();
  init_time = millis();
  steer_speed.target = 150;
  steer_speed.step = 3;
  forward_speed.target = 0;
  timer3 = millis();
}

void loop() {
//  if (Serial.available()) {
//    String values = Serial.readString();
//    String speed = getValue(values, ':', 1);
//    String steer = getValue(values, ':', 0);
//    forward_speed.target = speed.toInt();
//    steer_speed.target = steer.toInt();
//    debug << "Setting Speed, Steer to " << speed << " " << steer;
//  }
  if (millis() - last_time >= 10) {
    last_time = millis();
    motionController();
    
  }
  
}

void imuInit() {
  debug << "Looking for IMU :lupa:";
  if (!bno.begin())
  {
    Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR! :fail:");
    while (1); // halt for safety
  }
  delay(1000); // init delay
  bno.setExtCrystalUse(true);
  debug << "IMU init done :check:  Make robot stand on BALANCE_AT now.";
  float error = 9999;
  float theta = 1;
  while (abs(error) > 4) { // waiting for robot to stand
    imu::Vector<3> _euler = bno.getVector(Adafruit_BNO055::VECTOR_EULER);
    error = _euler.z() + BALANCE_AT;
  }
  info << "Robot is starting to stand now. :check:";
}
void motionController() {
 
  // IMU sampling
  imu::Vector<3> _euler = bno.getVector(Adafruit_BNO055::VECTOR_EULER);
  imu::Vector<3> _gyro = bno.getVector(Adafruit_BNO055::VECTOR_GYROSCOPE);
  float error = _euler.z() + BALANCE_AT;
  thetas[j % 10]= encoder1.getCount();
  float theta = thetas[j % 10];


  

  if (millis() - last_time2 > 4000){
    steer_speed.target = steer_speed.target * -1;
    last_time2 = millis();}
  // Balance controller
  
  forward_speed.eval();
  steer_speed.eval();

    float gyro_speed = (error - previous_error)/0.01; 
    float dtheta = 0;
      if (j >= 10) {
     dtheta = (thetas[j % 10]-thetas[(j+1) % 10])/(0.1*2400/(2*3.14));
  } else  {
     dtheta = (theta - previous_theta)/(0.01*2400/(2*3.14));
  }
    pid = 1.5*((K1*error + K2*dtheta + K3*gyro_speed) / 180 * 3.14);
    previous_error = error;
    //pid = atan(pid) * ((0.5 * abs(pid)) + 30);]
    long secondTime = millis();
  int position = encoder1.getCount();
  
  debug << "phi" << error << "dtheta " << dtheta << "dphi " << gyro_speed << " Control " << pid << " encoder " << position;

  previous_theta = theta;
  j = j+1;
  if (abs(error) > ANGLE_LIMIT || abs(pid) > SPEED_LIMIT) {
    breaked = true;
  }
  if (!breaked) {
    setHoverboard(-1 * (pid + forward_speed.current), -1 * (pid + forward_speed.current));
  }
  else {
    setHoverboard(0, 0);
    fail << "Robot is breaked at angle " << error << ", speed  " << pid << ".  :fire:";
    delay(100);
    if (abs(error) < 2 and abs(pid) < 100) {
      breaked = !breaked;
    }

  }
}
